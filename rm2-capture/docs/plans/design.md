Okay, I'd like to develop the design specification and ultimately an implementation plan for a Custom software that will run on my system. The purpose is to receive handwritten notes, scans of handwritten notes. Via a queue, which is behind the scenes implemented via an email account. And to process the scans, to do OCR on them And then add them to an obsidian vault for notes The idea here is that I use my Remarkable 2 e-ink tablet and to capture notes during conversations or brainstorming or um any kind of day-to-day work. I use my pen to do this. I write sometimes in nice handwriting, sometimes in not so nice handwriting. And it's frequently just text, freeform text, often in kind of and indented uh bulleted notes sort of format. Occasionally there's images, uh or rather diagrams I should say that I I create, but that's not my goal here. um to capture those. And sometimes I might have tables, handwritten tables, with uh text that is aligned via comma uh columns and rows sort of thing. But it's fairly free form. Now I want to be able to quickly uh send these to a saved email address and my my remarkable to tablet already has this functionality. I can just kind of select the page, click a button or two, and it emails a PDF document of the current page To that email address. Now, what I'd like is to write this software. It should be written in Python. It should be a long-running process. And it should Use the email credentials that I provide via environment variables. That specifies the email account name. Um as well as the password, and it should communicate via IMAP. um to look at the email the the given email account uh to enumerate the messages sent to it uh filtering by the given email address uh because I might use the the suffix of plus project name um after the email name uh to kind of specify that this is the sort of data that's being sent over. It should use that to filter down the messages to fetch the attachments, which are these PDF documents, or possibly PNG, but let's focus on PDF. because that's what's exported by their markable to tablet. I should download those. Then it should um Pass the PDF documents to an OCR provider and what we're gonna probably use here is either a local LLM That's exposed via LM Studio, running an open AI compatible endpoint. Or alternatively, we might just invoke Google's Gemini service. And we could use a command line tool like Simon Willison's LLM, a command line tool, with a prompt and the attachment there. to actually interact with Gemini service. Now that latter approach sounds the most flexible. We can just delegate all of kind of this integration to the sub-process. So probably we're going to start with this. And so we can assume LLM is going to be pre-installed and configured with the environment variables for the key and everything like that. Now we're gonna prompt the uh Gemini to do a uh verbatim. extraction of the text using the details that I mentioned earlier to extract markdown the appropriate for insertion into my obsidian vault. When the result from Gemini comes back and we're able to extract this markdown, which must be in a specific place, it must be in a way that we can extract it. So we don't really want preceding text or suffix text With Gemini's kind of like analysis, we just want that markdown that it produces. So maybe we expect there to be exactly one markdown. uh fence or or delimitation uh and we can extract all text within there assuming that itself will be marked down. And now we're going to put the results uh in the uh obsidian vault. Uh this will be specified again probably as uh an environment variable, not as an environment variable, but as a command line. parameter to the tool, the path to the obsidian vault. And we're going to put it under a specific subdirectory. And again, this will come from the uh command line parameter uh and so that'll be kind of like some path within the obsidian vault uh and we will write into a new name note whose name is derived from the subject of the email And or maybe the timestamp. This needs a little bit of kind of like thinking, how we figure out what the target note name is And then that's where we kind of create our note and put that content there. We may also want to attach the PDF document directly and link it. uh in the markdown document and put in the attachments directory next to the note. That way we have that kind of source uh source image as well of the uh what I actually wrote by hand. That would be awesome. Now we want our script to kind of be only searching or downloading and running this process for new emails. So we want to As we process them, we want to mark them as red so that we don't pre-process or process them again. And again, we don't want to process uh emails for whose output is already written. So we can use like the timestamp and or the subject to see whether or not we've already extracted that content. and avoid downloading and submitting to an LLM if that content is already in the markdown vault. Sometime in the future we want might want the ability to like maybe reprocess or re-extract the um the markdown, uh the notes from the PDF within this obsidian vault, uh, because we're gonna be uh putting the um the PDF into the vault. So we might want to be able to resubmit that to Gemini, re-extract and insert into Markdown. So maybe our core flow should actually be to when we fetch the email, the first thing that we actually do is write it into the vault, create a directory for the um for this new note with again the kind of name of the directory derived from the subject of the email uh and or the timestamp um And then creating the attachments directory. I think we use underscore attachments as the canonical place to put attachments. And we put the PDF there. And then the second step is actually to do this kind of OCR transcription to create the markdown. content. And this will allow us to maybe rerun extraction, kind of that final step in the pipeline. If, for example, there's a new Gemini model that comes out or we want to update the prompt that we use to do the extraction, this should be something that's kind of feasible. We don't want to implement this kind of refresh logic right now. We just want to make sure we design the software in such a way that we could build that. So help me kind of come up with a design and specification for this software. Ask me questions, help me clarify this. This shouldn't be that hard to do. But we do want to kind of get our design on paper, get an initial implementation in place, allow me to start playing with this flow and then make tweaks to it. So we want to use idiomatic Python libraries and styles. We don't want to over-engineer anything. We want it to remain very hackable, very understandable. So that's great. We expect this script to be running in the background. Maybe one day we add a user interface or even translate it to a different language because I'm running this on macOS. And so maybe even one day we rewrite it in Swift and have like a UI or something. The point though isn't to figure that out today. We just want to have simple code, simple scripts, very hackable to figure out exactly what we want. Because it's running long term in the background, we want to support uh IMAP and the extensions for uh be having notifications and messages received so then in real time we can be downloading the message writing it into the obsidian vault marking the message as red and uh doing the transcription. So make sure you kind of keep that into account. As always you we use things like um rich for colored output um and all the other kind of styles that I I typically use for Python code. So now get to work. Think about this. Kind of consider this. Ask me clarifying questions. Let's come up with a great design for this. Then we'll kind of codify it into a specification that is our living document that describes what we're doing. And after that we'll proceed with implementation.
